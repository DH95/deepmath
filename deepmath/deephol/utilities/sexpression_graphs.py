"""Turn SExpressions into graphs and then into a tensorflow-digestible format."""
from typing import Dict, Iterable, List, NewType, Optional, Set, Text, Tuple, Union
import farmhash
import six
import tensorflow.compat.v1 as tf
from deepmath.deephol.utilities import sexpression_parser

NodeID = NewType('NodeID', int)  # for nodes in the S-expression graph


def _children_to_node_id(child_node_ids: List[NodeID]) -> NodeID:
  """Computes the node ID given the IDs of its children.

  Args:
    child_node_ids: IDs for all the child nodes.

  Returns:
    The ID of the node.
  """
  assert child_node_ids
  return NodeID(
      farmhash.fingerprint64(' '.join(
          [str(child_node_id) for child_node_id in child_node_ids])))


def _without_children_to_node_id(sexp: Text) -> NodeID:
  """Computes the node ID for a leaf node.

  Args:
    sexp: The text representation of the S-expression represented by the node.

  Returns:
    The ID of the node.
  """
  return NodeID(farmhash.fingerprint64(sexp))


def _tree_to_node_id(root: sexpression_parser.SExpressionTreeNode) -> NodeID:
  """Computes the node ID for an S-expression tree.

  Args:
    root: The root node of the S-expression tree.

  Returns:
    The ID of the node.
  """
  node = root  # type: Optional[sexpression_parser.SExpressionTreeNode]
  child_node_id_stack = []  # type: List[List[NodeID]]
  # Will hold the resulting NodeID for the entire S-expression.
  child_node_id_stack.append([])
  # Will hold NodeID values for each child of the root node.
  child_node_id_stack.append([])
  while node is not None:
    if node.children:
      next_child_index = len(child_node_id_stack[-1])
      if next_child_index == len(node.children):
        node_id = _children_to_node_id(child_node_id_stack[-1])
        child_node_id_stack.pop()
        child_node_id_stack[-1].append(node_id)
        node = node.parent
      else:
        child_node_id_stack.append([])
        node = node.children[next_child_index]
    else:
      node_id = NodeID(farmhash.fingerprint64(repr(node)))
      child_node_id_stack.pop()
      child_node_id_stack[-1].append(node_id)
      node = node.parent
  assert len(child_node_id_stack) == 1
  assert len(child_node_id_stack[0]) == 1
  return child_node_id_stack[0][0]


def to_node_id(sexp: Text) -> NodeID:
  """Computes the node ID for an S-expression.

  Args:
    sexp: The text of the S-expression.

  Returns:
    The ID of the node.
  """
  if not sexp:
    return _without_children_to_node_id('')  # Allow empty nodes.
  return _tree_to_node_id(sexpression_parser.to_tree(sexp))


class SExpressionGraph(object):
  """Minimal graph representation of SExpressions generated by HOL Light.

  Nodes in this graph represent subexpressions.

  There are two types of edges: parent edges and child edges. The order of
  children is important; the order of parents is not.
  """

  def __init__(self, sexp=None):
    self.parents = {}  # type: Dict[NodeID, Set[NodeID]]
    self.children = {}  # type: Dict[NodeID, List[NodeID]]
    # Internal nodes have None label
    self.labels = {}  # type: Dict[NodeID, Optional[Text]]
    if sexp is not None:
      self.add_sexp(sexp)

  @property
  def nodes(self) -> Iterable[NodeID]:
    return self.children.keys()

  def __len__(self):
    """Returns the number of nodes in the DAG representation of the expr."""
    return len(self.labels)

  def add_sexp(self, sexp_source: Union[Text, Iterable[Text]]):
    """Adds new S-expressions; can be Text, or list of Text."""
    if not isinstance(sexp_source, six.string_types):
      for s in sexp_source:
        self.add_sexp(s)
      return
    self._add_text_sexp(sexp_source)

  def _add_text_sexp(self, sexp: Text):
    """Add new nodes to the S-expression graph."""
    if sexp:
      self._add_tree_sexp(sexpression_parser.to_tree(sexp))
      return
    # Allow empty nodes.
    node_id = _without_children_to_node_id('')
    self.children[node_id] = []
    self.parents[node_id] = set()
    self.labels[node_id] = ''

  def _add_node_via_node_ids(self, node_id: NodeID, label: Optional[Text],
                             child_node_ids: List[NodeID]) -> None:
    """Adds a new node to the graph with given children.

    Args:
      node_id: The ID of the node to be added.
      label: An optional label for the node to be added.
      child_node_ids: IDs of all the child nodes which are already in the graph.
    """
    if node_id in self.labels:
      if (self.labels[node_id] != label or
          self.children[node_id] != child_node_ids):
        tf.logging.fatal('Fingerprint collision in S-expression graph parser.')
      return
    self.children[node_id] = []
    self.parents[node_id] = set()
    self.labels[node_id] = label
    for child_node_id in child_node_ids:
      self.children[node_id].append(child_node_id)
      self.parents[child_node_id].add(node_id)

  def _add_tree_sexp(self,
                     root: sexpression_parser.SExpressionTreeNode) -> None:
    """Adds new nodes for the given S-expression tree to the graph.

    Args:
      root: The root node of the S-expression tree.
    """
    node = root  # type: Optional[sexpression_parser.SExpressionTreeNode]
    child_node_id_stack = []  # type: List[List[NodeID]]
    # Will hold the NodeID for the entire S-expression.
    child_node_id_stack.append([])
    # Will hold NodeID values for each child of the root node.
    child_node_id_stack.append([])
    while node is not None:
      if node.children:
        next_child_index = len(child_node_id_stack[-1])
        if next_child_index == len(node.children):
          node_id = _children_to_node_id(child_node_id_stack[-1])
          self._add_node_via_node_ids(node_id, None, child_node_id_stack[-1])
          child_node_id_stack.pop()
          child_node_id_stack[-1].append(node_id)
          node = node.parent
        else:
          child_node_id_stack.append([])
          node = node.children[next_child_index]
      else:
        node_id = _without_children_to_node_id(repr(node))
        self._add_node_via_node_ids(node_id, repr(node), [])
        child_node_id_stack.pop()
        child_node_id_stack[-1].append(node_id)
        node = node.parent

  def is_empty_string(self) -> bool:
    """Checks if the graph represents the empty string."""
    return len(self.parents) == 1 and to_node_id('') in self.parents

  def is_leaf_node(self, node: NodeID) -> bool:
    return node in self.labels and self.labels[node] is not None

  def global_post_order(self, skip_first_child=False) -> Dict[NodeID, int]:
    order = {}
    for n in self.roots():  # roots is sorted by hash, hence output is unique
      self.post_order(n, order=order, skip_first_child=skip_first_child)
    return order

  def post_order(self,
                 node: NodeID,
                 order=None,
                 skip_first_child=False) -> Dict[NodeID, int]:
    """Compute the unique post order for the given node.

    Non-recursive implementation of the following code:
      if node in order:
        return order
      for c in self.children[node]:
        post_order(c, order)
      order[node] = len(order)+1

    Using a non-recursive implementation as the expressions can become quite
    large, so there is the risk to run into stack overflows. As we use this in
    large pipelines, such errors could be quite costly.

    Args:
      node: node indicating the subexpression to start from.
      order: For internal use only; used for partial mappings.
      skip_first_child: Ignore the first child of each node. This helps us to
        skip nodes that do not show up in certain tree representations of HOL
        Light terms.

    Returns:
      Mapping from NodeIDs to unique consecutive integers starting from 0.
    """
    if order is None:
      order = {}
    order_id = len(order)
    stack = [node]
    while stack:
      node = stack[-1]  # node will only be popped when children are processed
      if node in order:
        stack.pop()
        continue
      all_children_in_order = True
      children = self.children[node]
      if skip_first_child:
        children = children[1:]
      for c in children[::-1]:  # reversed, so that stack.pop is in order
        if c not in order:
          # process all children before node, which is still on the stack
          stack.append(c)
          all_children_in_order = False
      if all_children_in_order:
        stack.pop()
        order[node] = order_id
        order_id += 1
    return order

  def to_text(self, node_id: NodeID) -> Text:
    """Return the string of the S-expression represented by node_id."""

    def space_needed(worklist):
      """Slightly hacky but works for s-expressions."""
      return worklist and worklist[-1] != ')'

    # Traverse the DAG as a tree; respect the order of the children and insert
    # parentheses where needed.
    tokens = []
    worklist = [node_id]  # contains node_ids and closing parens
    while worklist:
      item = worklist.pop()  # pops the last item
      if item == ')':
        tokens.append(item)
        if space_needed(worklist):
          tokens.append(' ')
        continue

      node_id = item
      if self.is_leaf_node(node_id):
        tokens.append(self.labels[node_id])
        if space_needed(worklist):
          tokens.append(' ')
      else:
        tokens.append('(')
        worklist.append(')')
        for c in self.children[node_id][::-1]:
          worklist.append(c)
    return ''.join(tokens)

  def to_token_arity_pair_list(self, root: NodeID) -> List[Tuple[Text, int]]:
    """Reperesent the S-expression as a list of (token, arity)-pairs.

    This representation is useful for representing the formulas uniquely
    without parentheses in a way that the reconstruction of the formula
    is straightforward algorithmically.

    For example, (v (bool) x) will be represented as [('v', 3), ('bool', 1),
      ('x', 0)]
    For each token that has an opening parenthesis in the left, the arity counts
    the number of top-level subexpressions within that parenthesis.

    Args:
      root: NodeId of the root node of the graph representing the S-expression.

    Returns:
      A list of (token, arity) pairs that represents the s-expression in the
      following way: arity is zero for any token that does not have an opening
      parenthesis to the left of the token. If a token had an opening
      parenthesis, then the arity field for the token is the number of child
      nodes in the parenthesis starting with that token.
    """
    tokens = []
    worklist = [(root, 0)]  # contains (node_id, arity) pairs.
    while worklist:
      node_id, arity = worklist.pop()  # pops the last item
      if self.is_leaf_node(node_id):
        tokens.append((self.labels[node_id], arity))
      else:
        children = self.children[node_id]
        for c in children[1:][::-1]:
          worklist.append((c, 0))
        worklist.append((children[0], len(children)))
    return tokens

  # TODO(mrabe): maybe introduce field maintaining the list of roots?
  def roots(self):
    """Returns all nodes without parents; sorted by hash value."""
    roots = [n for n in self.nodes if not self.parents[n]]
    roots.sort()
    return roots

  def is_abstraction(self, node):
    """Relies on the S-expression originating from HOL Light."""
    if self.is_leaf_node(node):
      return False
    return self.labels[self.children[node][0]] == 'l'

  def get_bound_variable(self, node) -> Optional[Text]:
    """Relies on the S-expression originating from HOL Light."""
    if not self.is_abstraction(node):
      return None
    variable_node = self.children[node][1]
    if self.labels[self.children[variable_node][0]] != 'v':
      raise ValueError(
          'Expected a variable node (v <type> <var_name>). Expression was %s' %
          self.to_text(node))
    if not self.is_leaf_node(self.children[variable_node][2]):
      raise ValueError(
          'Expected a variable node (v <type> <var_name>). Expression was: %s' %
          self.to_text(node))
    return self.labels[self.children[variable_node][2]]

  def is_variable(self, node):
    """Relies on the s-expression originating from HOL Light."""
    if self.is_leaf_node(node):
      return False
    return self.labels[self.children[node][0]] == 'v'

  def is_variable_name(self, node):
    """Relies on the S-expression originating from HOL Light."""
    if not self.is_leaf_node(node):
      return False
    return any([
        self.is_variable(p) and self.children[p][2] == node
        for p in self.parents[node]
    ])


def token_arity_pairs_to_sexpr(pairs: List[Tuple[Text, int]]) -> List[Text]:
  """Reconstruct the s-expression from its (token, arity) representation.

  Cf. SExpressionGraph.to_token_arity_pair_list method. Given a
  representation of the SExpression in (token, arity)-list format, this
  method recovers the list of tokens of the standard textual representation
  of the expression

  Args:
    pairs: List of (token, arity) pairs of the expression.

  Returns:
    A list of tokens (including parenthesis) for the S-expression.
    the text of the s-expression can be recovered by using joining the
    output using space and replacing repeated white-spaces and removing
    white-spaces between parentheses.
  """
  output = []
  stack = []
  for t, arity in pairs:
    if arity > 0:
      output.append('(')
      output.append(t)
      stack.append(arity)
    else:
      output.append(t)
    if stack:
      assert stack[-1] > 0
      stack[-1] -= 1
    while stack and stack[-1] == 0:
      output.append(')')
      stack.pop()
      if stack:
        assert stack[-1] > 0
        stack[-1] -= 1
  assert not stack
  return output
